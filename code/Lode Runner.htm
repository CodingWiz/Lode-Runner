<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
  <head>
  
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Lode Runner par Andrew Chedid et Mohamed H. Guelleh</title>
    <link rel="stylesheet" type="text/css" href="" />

    <script type="text/javascript">
      /*function strSprite (options) {
          
          var img = {};
          frameIndex = 0,
          tickCount = 0,
          ticksPerFrame = 0;
          numberOfFrames = options.numberOfFrames || 1;
                
          img.context = options.context;
          img.width = options.width;
          img.height = options.height;
          img.image = options.image;

          img.render = function () {
            // Draw the animation
            img.context.drawImage(img.image, frameIndex * img.width / numberOfFrames, 0, img.width / numberOfFrames, img.height, 0, 0, img.width / numberOfFrames, img.height);
          };

          img.loop = options.loop;

          img.update = function () {
            tickCount += 1;

            if (tickCount > ticksPerFrame) {
              tickCount = 0;

              // If the current frame index is in range
              if (frameIndex < numberOfFrames - 1) {	
                  // Go to the next frame
                  frameIndex += 1;
              }	else if (img.loop) {
                frameIndex = 0;
              }
            }
          };
      
          return img;
      }

      function initLoadRunner() {
        var objCanvas = document.getElementById('monCanvas'),
            objC2D = objCanvas.getContext('2d');

        objCanvas.focus();
        
        var width = objCanvas.width, 
            height = objCanvas.height;
        
        var imgTest = new Image();
        imgTest.src = "https://cdn.codeandweb.com/blog/2016/05/10/how-to-create-a-sprite-sheet/spritestrip.png";

        var test = strSprite({
          context: objC2D,
          width: 256,
          height: 256,
          image: imgTest
        });

        window.requestAnimationFrame(initLoadRunner);
        
        test.update();
        test.render();

        // Start the game loop as soon as the strSprite sheet is loaded
        test.addEventListener("load", initLoadRunner);
      }*/

      /*function gameLoop () {
        window.requestAnimationFrame(initLoadRunner);

        coin.update();
        coin.render();
      }*/

      
      

      // variables constantes
      const intNiveau_1 = 1, intNiveau_2 = 2, intNiveau_3 = 3;
      const intNum_Cell_X = 28, intNum_Cell_Y = 17;

      /* legende de la carte du niveau : 
          $ = or
          @ = Joueur
          ! = garde
          H = escalier
          | = escalier final
          - = corde
          # = passerelle de brique
          ~ = sol
            = vide
      */
     // array constante globale qui contient les cartes des differents niveau
      const arrNiveau_Map = [ 
        "                  |         " + // carte du niveau 1
        "    $             |         " +
        "#######H#######   |         " +
        "       H----------|    $    " +
        "       H    ##H   #######H##" +
        "       H    ##H          H  " +
        "     ! H    ##H       $! H  " +
        "##H#####    ########H#######" +
        "  H                 H       " +
        "  H           !     H       " +
        "#########H##########H       " +
        "         H          H       " +
        "       $ H----------H   $   " +
        "    H######         #######H" +
        "    H         @  $         H" +
        "############################" + 
        "~~~~~~~~~~~~~~~~~~~~~~~~~~~~" 
      ];
      // constantes globales qui contiennent les photos/sprites
      const strSprite_Or = "", 
            strSprite_Joueur = "joueur test", 
            strSprite_Garde = "", 
            strSprite_Escalier = "", 
            strSprite_Escalier_Final = "", 
            strSprite_Corde = "", 
            strSprite_Brique = "", 
            strSprite_Sol = "",
            strSprite_Vide = "";

      // variables globales
      var objStage = null; // stage qui contient tous les enfants a dessiner et a mettre dans le jeu
      var objSprite_Sheet = null;

      var objJoueur = null, // lode runner que le Joueur controle
          objMap = null, // representation des cellules dans un tableau array en 2d
          intNiveau_Courant = 0, // niveau courant du joueur
          intOr_Count = 0, // compte le nombre d'or qu'il y a dans le jeu
          intGarde_Count = 0; // compte le nombre de garde qu'il y a dans le jeu

      var RUNNER_SPEED = 0.65;
      var BASE_TILE_X = 40,
	        BASE_TILE_Y = 44;


      // remettre les variables globales aux valeurs par defaut
      function remettreVariables(objCanvas) {
        // redefini la fonction stage et le met dans la variable objStage
        objStage = stage({ 
          name: "Main stage",
          canvas: objCanvas,
          toString: function() {
            return "[Stage  (name = "+  this.name +")]";
          }
        });

        // redefini la fonction joueur et le met dans la variable objJoueur
        objJoueur = joueur({
        });

        objSprite_Sheet = spriteSheet({
          images: [runnerImage],
		
          frames: {
            regX:0, 
            height: BASE_TILE_Y,  
            regY:0, 
            width: BASE_TILE_X
          },
          
          animations: { 
            runRight: [0,2, "runRight", RUNNER_SPEED], 
            runLeft : [3,5, "runLeft",  RUNNER_SPEED], 
            runUpDn : [6,7, "runUpDn",  RUNNER_SPEED],

            barRight: {
              frames: [ 18, 19, 19, 20, 20 ],
              next:  "barRight",
              speed: RUNNER_SPEED
            },

            barLeft: {
              frames: [ 21, 22, 22, 23, 23 ],
              next:  "barLeft",
              speed: RUNNER_SPEED
            },
                
            digRight: 24,
            digLeft : 25,

            fallRight : 8,
            fallLeft: 26
          }
        });

        objMap = [[]];

        intNiveau_Courant = intNiveau_1; // niveau 1 par defaut

        intOr_Count = 0;
        intGarde_Count = 0;
      }

      // construire le niveau
      function construireNiveau(niveau) {
        //objMap = [[]];
        var intNiveau_Charactere_Count = 0; // retourne le charactere aux positions (x,y) du niveau

        for (var x = 0; x < intNum_Cell_X; x++) { // parcours les cellules horizontales
          // https://stackoverflow.com/questions/966225/how-can-i-create-a-two-dimensional-array-in-javascript
          objMap[x] = []; // genere une erreure si on ne mets pas ca --> you have to set myArray[1]=[]; before assigning myArray[1][0]=5;

          for (var y = 0; y < intNum_Cell_Y; y++) { // parcours les cellues verticales
            objMap[x][y] = {}; // cree un nouveau objet aux coordonnees (x,y)

            // retourne le charactere aux positions (x,y) du niveau
            var strNiveau_Charactere = niveau.charAt(intNiveau_Charactere_Count++);
            objMap[x][y].strType = strNiveau_Charactere;
            objStage.addChild(strNiveau_Charactere);

            switch(strNiveau_Charactere) {
              /* legende de la carte du niveau : 
                  $ = or
                  @ = Joueur
                  ! = garde
                  H = escalier
                  | = escalier final
                  - = corde
                  # = passerelle de brique
                  ~ = sol
                    = vide
              */
              case "$": 
                objMap[x][y].strSprite = strSprite_Or; 
                intOr_Count++; 

                break;
              case "@": 
                objMap[x][y].strSprite = objJoueur.strSprite = strSprite_Joueur; 
                break;
              case "!": 
                objMap[x][y].strSprite = strSprite_Garde; 
                intGarde_Count++; 

                break;
              case "H": 
                objMap[x][y].strSprite = strSprite_Escalier; 

                break;
              case "|": 
                objMap[x][y].strSprite = strSprite_Escalier_Final; 

                break;
              case "-": 
                objMap[x][y].strSprite = strSprite_Corde; 

                break;
              case "#": 
                objMap[x][y].strSprite = strSprite_Brique; 

                break;
              case "~": 
                objMap[x][y].strSprite = strSprite_Sol; 

                break;
              case " ": 
                objMap[x][y].strSprite = strSprite_Vide; 

                break;
            }
          }
        }

        /*console.log(objStage.children);
        console.log(objStage.getNumChildren());
        console.log(objStage.getChildIndex("@"));
        console.log(objStage.getChildAt(406));

        objStage.removeChild("@");

        console.log(objStage.children);
        console.log(objStage.getNumChildren());
        console.log(objStage.getChildIndex("@"));
        console.log(objStage.getChildAt(406));*/

        //console.log(objJoueur.strSprite);

        /*var niveau_Charactere = 0;
        for (var x = 0; x < intNum_Cell_X; x++) { // parcours les cellules horizontales
          for (var y = 0; y < intNum_Cell_Y; y++) { // parcours les cellues verticales
            switch(niveau.charAt(niveau_Charactere++)) { // retourne le charactere aux positions (x,y) du niveau

            }
          }
        }*/
      }

      function initLodeRunner() { // demarre le jeu
        // variables canvas 
        var objCanvas = document.getElementById('monCanvas'),
          objC2D = objCanvas.getContext('2d');

        objCanvas.focus();
        
        var canvas_Width = objCanvas.width, 
            canvas_Height = objCanvas.height;
        
        remettreVariables(objCanvas);
        construireNiveau(arrNiveau_Map[intNiveau_Courant-1]);
      }

      // fonction stage qui initialise l'objet stage et elle est redefinie par celui-ci a chaque fois qu'on appelle la fonction remettreVariable()
      function stage() {
        // objet qui est retourne par la fonction
        var object_Stage = {};

        object_Stage.name = null;

        object_Stage.canvas = null;

        object_Stage.drawRect = null;

        object_Stage.children = [];
        
        object_Stage.getChildAt = function(index) {
          return this.children[index];
        };
        object_Stage.getChildByName = function(name) {
          var kids = this.children;
          for (var i=0,l=kids.length;i<l;i++) {
            if(kids[i].name == name) { return kids[i]; }
          }
          return null;
        };
        object_Stage.getChildIndex = function(child) {
          return this.indexOf(this.children, child);
        };
        object_Stage.getNumChildren = function () {
          return this.children.length;
        };

        object_Stage.addChild = function(child) {
          if (child == null) { return child; }
          var l = arguments.length;
          if (l > 1) {
            for (var i=0; i<l; i++) { this.addChild(arguments[i]); }
            return arguments[l-1];
          }
          // Note: a lot of duplication with addChildAt, but push is WAY faster than splice.
          var par=child.parent, silent = par === this;
          par&&par._removeChildAt(this.indexOf(par.children, child), silent);
          child.parent = this;
          this.children.push(child);
          //if (!silent) { child.dispatchEvent("added"); }
          return child;
        };
        object_Stage.addChildAt = function(child, index) {
          var l = arguments.length;
          var indx = arguments[l-1]; // can't use the same name as the index param or it replaces arguments[1]
          if (indx < 0 || indx > this.children.length) { return arguments[l-2]; }
          if (l > 2) {
            for (var i=0; i<l-1; i++) { this.addChildAt(arguments[i], indx+i); }
            return arguments[l-2];
          }
          var par=child.parent, silent = par === this;
          par&&par._removeChildAt(this.indexOf(par.children, child), silent);
          child.parent = this;
          this.children.splice(index, 0, child);
          //if (!silent) { child.dispatchEvent("added"); }
          return child;
        };

        object_Stage._removeChildAt = function(index, silent) {
          if (index < 0 || index > this.children.length-1) { return false; }
          var child = this.children[index];
          if (child) { child.parent = null; }
          this.children.splice(index, 1);
          //if (!silent) { child.dispatchEvent("removed"); }
          return true;
        };
        object_Stage.removeChild = function(child) {
          var l = arguments.length;
          if (l > 1) {
            var good = true;
            for (var i=0; i<l; i++) { good = good && this.removeChild(arguments[i]); }
            return good;
          }
          return this._removeChildAt(this.indexOf(this.children, child));
        };
        object_Stage.removeChildAt = function(index) {
          var l = arguments.length;
          if (l > 1) {
            var a = [];
            for (var i=0; i<l; i++) { a[i] = arguments[i]; }
            a.sort(function(a, b) { return b-a; });
            var good = true;
            for (var i=0; i<l; i++) { good = good && this._removeChildAt(a[i]); }
            return good;
          }
          return this._removeChildAt(index);
        };
        object_Stage.removeAllChildren = function() {
          var kids = this.children;
          while (kids.length) { this._removeChildAt(0); }
        };

        object_Stage.sortChildren = function(sortFunction) {
          this.children.sort(sortFunction);
        };

        /*clone: function(recursive) {
          var o = this._cloneProps(new Container());
          if (recursive) { this._cloneChildren(o); }
          return o;
        },*/
        
        object_Stage.toString = null;

        object_Stage.isVisible = function() {
          var hasContent = this.cacheCanvas || this.children.length;
          return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
        };
        object_Stage.draw = function(ctx, ignoreCache) {
          if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
          
          // this ensures we don't have issues with display list changes that occur during a draw:
          var list = this.children.slice();
          for (var i=0,l=list.length; i<l; i++) {
            var child = list[i];
            if (!child.isVisible()) { continue; }
            
            // draw the child:
            ctx.save();
            child.updateContext(ctx);
            child.draw(ctx);
            ctx.restore();
          }
          return true;
        };

        object_Stage.mouseChildren = true;
        object_Stage.tickChildren = true;

        object_Stage.clear = function() {
          if (!this.canvas) { return; }
          var ctx = this.canvas.getContext("2d");
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1);
        };

        object_Stage.indexOf = function (array, searchElement){          
          for (var i = 0, l=array.length; i < l; i++) {
            if (searchElement === array[i]) {
              return i;
            }
          }
          return -1;
        };

        return object_Stage;
      }

      // fonction stage qui initialise l'objet joueur et elle est redefinie par celui-ci a chaque fois qu'on appelle la fonction remettreVariable()
      function joueur() {
        // objet qui est retourne par la fonction
        var object_Joueur = {};

        object_Joueur.strSprite = null;

        return object_Joueur;
      }

      function spriteSheet() {
        var object_SpriteSheet = {};

        object_SpriteSheet.images = null;

        object_SpriteSheet.frames = null;

        object_SpriteSheet.animations = null;

        return object_SpriteSheet;
      }
    </script>
  </head>
  
  
  <body onload="initLodeRunner()"> 
    <canvas id="monCanvas" width="1440" height="1088" tabIndex="1" onkeydown="";>
      Votre navigateur ne supporte pas la balise canvas
    </canvas>
  </body>
</html>