<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
  <head>
  
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Lode Runner par Andrew Chedid et Mohamed H. Guelleh</title>
    <link rel="stylesheet" type="text/css" href="" />

    <script type="text/javascript" src="Graphics.js"></script>

    <script type="text/javascript">
      /*function strSprite (options) {
          
          var img = {};
          frameIndex = 0,
          tickCount = 0,
          ticksPerFrame = 0;
          numberOfFrames = options.numberOfFrames || 1;
                
          img.context = options.context;
          img.width = options.width;
          img.height = options.height;
          img.image = options.image;

          img.render = function () {
            // Draw the animation
            img.context.drawImage(img.image, frameIndex * img.width / numberOfFrames, 0, img.width / numberOfFrames, img.height, 0, 0, img.width / numberOfFrames, img.height);
          };

          img.loop = options.loop;

          img.update = function () {
            tickCount += 1;

            if (tickCount > ticksPerFrame) {
              tickCount = 0;

              // If the current frame index is in range
              if (frameIndex < numberOfFrames - 1) {	
                  // Go to the next frame
                  frameIndex += 1;
              }	else if (img.loop) {
                frameIndex = 0;
              }
            }
          };
      
          return img;
      }

      function initLoadRunner() {
        var objCanvas = document.getElementById('monCanvas'),
            objC2D = objCanvas.getContext('2d');

        objCanvas.focus();
        
        var width = objCanvas.width, 
            height = objCanvas.height;
        
        var imgTest = new Image();
        imgTest.src = "https://cdn.codeandweb.com/blog/2016/05/10/how-to-create-a-sprite-sheet/spritestrip.png";

        var test = strSprite({
          context: objC2D,
          width: 256,
          height: 256,
          image: imgTest
        });

        window.requestAnimationFrame(initLoadRunner);
        
        test.update();
        test.render();

        // Start the game loop as soon as the strSprite sheet is loaded
        test.addEventListener("load", initLoadRunner);
      }*/

      /*function gameLoop () {
        window.requestAnimationFrame(initLoadRunner);

        coin.update();
        coin.render();
      }*/

      
      

      // variables constantes
      const intNiveau_1 = 1, intNiveau_2 = 2, intNiveau_3 = 3;
      const intNum_Cell_X = 28, intNum_Cell_Y = 17;

      /* legende de la carte du niveau : 
          $ = or
          @ = Joueur
          ! = garde
          H = escalier
          | = escalier final
          - = corde
          # = passerelle de brique
          ~ = sol
            = vide
      */
     // array constante globale qui contient les cartes des differents niveau
      const arrNiveau_Map = [ 
        "                  |         " + // carte du niveau 1
        "    $             |         " +
        "#######H#######   |         " +
        "       H----------|    $    " +
        "       H    ##H   #######H##" +
        "       H    ##H          H  " +
        "     ! H    ##H       $! H  " +
        "##H#####    ########H#######" +
        "  H                 H       " +
        "  H           !     H       " +
        "#########H##########H       " +
        "         H          H       " +
        "       $ H----------H   $   " +
        "    H######         #######H" +
        "    H         @  $         H" +
        "############################" + 
        "~~~~~~~~~~~~~~~~~~~~~~~~~~~~" 
      ];
      // constantes globales qui contiennent les photos/sprites
      const srcSprites = "../assets/sprites/";
      const strSprite_Or = srcSprites + "gold.png", 
            strSprite_Joueur = srcSprites + "runner1.png", 
            strSprite_Garde = srcSprites + "guard1.png", 
            strSprite_Escalier = srcSprites + "ladder.png", 
            strSprite_Corde = srcSprites + "rope.png", 
            strSprite_Brique = srcSprites + "brick.png", 
            strSprite_Sol = srcSprites + "block.png",
            strSprite_Vide = srcSprites + "empty.png";

      // variables globales
      var objCanvas = null, 
          objC2D = null;

      var objStage = null; // stage qui contient tous les enfants a dessiner et a mettre dans le jeu

      // variables globales pour init les images
      var imgOr = new Image(),
          imgJoueur = new Image(),
          imgGarde = new Image(),
          imgEscalier = new Image(),
          imgCorde = new Image(),
          imgBrique = new Image(),
          imgSol = new Image(),
          imgVide = new Image();

      var objJoueur = null, // lode runner que le Joueur controle
          objMap = null, // representation des cellules dans un tableau array en 2d
          intNiveau_Courant = 0, // niveau courant du joueur
          intOr_Count = 0, // compte le nombre d'or qu'il y a dans le jeu
          intGarde_Count = 0; // compte le nombre de garde qu'il y a dans le jeu

      //var RUNNER_SPEED = 0.65;
      /*var BASE_TILE_X = 40,
	        BASE_TILE_Y = 44;*/


      // remettre les variables globales aux valeurs par defaut
      function remettreVariables() {
        // redefini la fonction stage et le met dans la variable objStage
        objStage = object_Stage({ 
          name: "Main stage",
          toString: function() {
            return "[Stage  (name = "+  this.name +")]";
          }
        });

        // redefini la fonction joueur et le met dans la variable objJoueur
        objJoueur = object_Joueur({
        });

        /*objSprite_Sheet = object_SpriteSheet({
          images: [runnerImage],
		
          frames: {
            regX:0, 
            height: BASE_TILE_Y,  
            regY:0, 
            width: BASE_TILE_X
          },
          
          animations: { 
            runRight: [0,2, "runRight", RUNNER_SPEED], 
            runLeft : [3,5, "runLeft",  RUNNER_SPEED], 
            runUpDn : [6,7, "runUpDn",  RUNNER_SPEED],

            barRight: {
              frames: [ 18, 19, 19, 20, 20 ],
              next:  "barRight",
              speed: RUNNER_SPEED
            },

            barLeft: {
              frames: [ 21, 22, 22, 23, 23 ],
              next:  "barLeft",
              speed: RUNNER_SPEED
            },
                
            digRight: 24,
            digLeft : 25,

            fallRight : 8,
            fallLeft: 26
          }
        });*/

        objMap = [[]];

        intNiveau_Courant = intNiveau_1; // niveau 1 par defaut

        intOr_Count = 0;
        intGarde_Count = 0;
      }

      // construire le niveau
      function construireNiveau(niveau) {
        // retourne le charactere aux positions (x,y) du niveau
        var intNiveau_Charactere_Count = 0; 

        for (var x = 0; x < intNum_Cell_X; x++) { // parcours les cellules horizontales
          // https://stackoverflow.com/questions/966225/how-can-i-create-a-two-dimensional-array-in-javascript
          objMap[x] = []; // genere une erreure si on ne mets pas ca --> you have to set myArray[1]=[]; before assigning myArray[1][0]=5;

          for (var y = 0; y < intNum_Cell_Y; y++) { // parcours les cellues verticales
            objMap[x][y] = {}; // cree un nouveau objet aux coordonnees (x,y)

            // retourne le charactere aux positions (x,y) du niveau
            var strNiveau_Charactere = niveau.charAt(intNiveau_Charactere_Count++);
            //strType = strNiveau_Charactere;

            //var img = new Image();
            /*var img = new Image();
            img.src = "../assets/sprites/block.png";*/
            /*img.onload = function() {
              objC2D.drawImage(img, x*48, 0);
            } */
            var img;
            switch(strNiveau_Charactere) {
              /* legende de la carte du niveau : 
                  $ = or
                  @ = Joueur
                  ! = garde
                  H = escalier
                  | = escalier final
                  - = corde
                  # = passerelle de brique
                  ~ = sol
                    = vide
              */
              case "$": 
                intOr_Count++; 
                
                img = imgOr; 
                objStage.addChild(img);

                break;
              case "@": 
                img = objJoueur.img = imgJoueur; 
                objStage.addChild(img);

                break;
              case "!":
                intGarde_Count++; 

                img = imgGarde; 
                objStage.addChild(img);

                break;
              case "H": 
                img = imgEscalier; 
                objStage.addChild(img);

                break;
              case "|": 
                img = imgEscalier; 
                objStage.addChild(img);

                break;
              case "-": 
                img = imgCorde; 
                objStage.addChild(img);

                break;
              case "#":
                img = imgBrique; 
                objStage.addChild(img);

                break;
              case "~": 
                img = imgSol; 
                objStage.addChild(img);

                break;
              case " ": 
                img = imgVide; 
                objStage.addChild(img);

                break;
            }

            console.log(img.complete);

            /*if (img.complete && img.naturalWidth !== 0 && img.naturalHeight !== 0) {
              objC2D.drawImage(img, x*50, y*50);
            }
            else {*/
              onloadImages(img, x*50, y*50);
              /*img.onload = function() {
                objC2D.drawImage(img, x*50, y*50);
              }*/
            //}

            //console.log(strNiveau_Charactere);
            //objC2D.drawImage(img, x*50, y*50);
            //console.log(x + ", " + y);

            //console.log(objCanvas.width + ", " + objCanvas.height);

            //console.log(objStage.getChildAt(intNiveau_Charactere_Count));
          }
        }

        

        /*console.log(objStage.children);
        console.log(objStage.getNumChildren());
        console.log(objStage.getChildIndex("@"));
        console.log(objStage.getChildAt(406));

        objStage.removeChild("@");

        console.log(objStage.children);
        console.log(objStage.getNumChildren());
        console.log(objStage.getChildIndex("@"));
        console.log(objStage.getChildAt(406));*/

        //console.log(objJoueur.img);
      }

      /* legende de la carte du niveau : 
          $ = or
          @ = Joueur
          ! = garde
          H = escalier
          | = escalier final
          - = corde
          # = passerelle de brique
          ~ = sol
            = vide
      */
      function initLodeRunner() { // demarre le jeu
        // variables canvas 
        objCanvas = document.getElementById('monCanvas');
        objC2D = objCanvas.getContext('2d');

        objCanvas.focus();
        
        var canvas_Width = objCanvas.width, 
            canvas_Height = objCanvas.height;

        initImages();
        
        remettreVariables();

        construireNiveau(arrNiveau_Map[intNiveau_Courant-1]);
      }

      // initialise les images
      function initImages() {
        imgOr.src = strSprite_Or;
        imgJoueur.src = strSprite_Joueur;
        imgGarde.src = strSprite_Garde;
        imgEscalier.src = strSprite_Escalier;
        imgCorde.src = strSprite_Corde;
        imgBrique.src = strSprite_Brique;
        imgSol.src = strSprite_Sol;
        imgVide.src = strSprite_Vide;
      }
      function onloadImages(img, x, y) {
        img.onload = function() {
          objC2D.drawImage(img, x, y);
          //console.log(x + ", " + y);
          //console.log(objStage.children);
        }
      }

      // fonction stage qui initialise l'objet stage et elle est redefinie par celui-ci a chaque fois qu'on appelle la fonction remettreVariable()
      function object_Stage() {
        // objet qui est retourne par la fonction
        var object_Stage = {};

        object_Stage.name = null;
        object_Stage.toString = null;

        // ??????????????????????????????
        /*object_Stage.mouseChildren = true;
        object_Stage.tickChildren = true;*/

        object_Stage.canvas = objCanvas;

        //object_Stage.drawRect = null;

        object_Stage.children = [];
        
        object_Stage.getChildAt = function(index) {
          return this.children[index];
        };
        object_Stage.getChildByName = function(name) {
          var kids = this.children;
          for (var i=0,l=kids.length;i<l;i++) {
            if(kids[i].name == name) { return kids[i]; }
          }
          return null;
        };
        object_Stage.getChildIndex = function(child) {
          return this.indexOf(this.children, child);
        };
        object_Stage.getNumChildren = function () {
          return this.children.length;
        };

        object_Stage.addChild = function(child) {
          if (child == null) { return child; }
          var l = arguments.length;
          if (l > 1) {
            for (var i=0; i<l; i++) { this.addChild(arguments[i]); }
            return arguments[l-1];
          }
          // Note: a lot of duplication with addChildAt, but push is WAY faster than splice.
          var par=child.parent, silent = par === this;
          par&&par._removeChildAt(this.indexOf(par.children, child), silent);
          child.parent = this;
          this.children.push(child);
          //if (!silent) { child.dispatchEvent("added"); }
          return child;
        };
        object_Stage.addChildAt = function(child, index) {
          var l = arguments.length;
          var indx = arguments[l-1]; // can't use the same name as the index param or it replaces arguments[1]
          if (indx < 0 || indx > this.children.length) { return arguments[l-2]; }
          if (l > 2) {
            for (var i=0; i<l-1; i++) { this.addChildAt(arguments[i], indx+i); }
            return arguments[l-2];
          }
          var par=child.parent, silent = par === this;
          par&&par._removeChildAt(this.indexOf(par.children, child), silent);
          child.parent = this;
          this.children.splice(index, 0, child);
          //if (!silent) { child.dispatchEvent("added"); }
          return child;
        };

        object_Stage._removeChildAt = function(index, silent) {
          if (index < 0 || index > this.children.length-1) { return false; }
          var child = this.children[index];
          if (child) { child.parent = null; }
          this.children.splice(index, 1);
          //if (!silent) { child.dispatchEvent("removed"); }
          return true;
        };
        object_Stage.removeChild = function(child) {
          var l = arguments.length;
          if (l > 1) {
            var good = true;
            for (var i=0; i<l; i++) { good = good && this.removeChild(arguments[i]); }
            return good;
          }
          return this._removeChildAt(this.indexOf(this.children, child));
        };
        object_Stage.removeChildAt = function(index) {
          var l = arguments.length;
          if (l > 1) {
            var a = [];
            for (var i=0; i<l; i++) { a[i] = arguments[i]; }
            a.sort(function(a, b) { return b-a; });
            var good = true;
            for (var i=0; i<l; i++) { good = good && this._removeChildAt(a[i]); }
            return good;
          }
          return this._removeChildAt(index);
        };
        object_Stage.removeAllChildren = function() {
          var kids = this.children;
          while (kids.length) { this._removeChildAt(0); }
        };

        object_Stage.sortChildren = function(sortFunction) {
          this.children.sort(sortFunction);
        };

        /*clone: function(recursive) {
          var o = this._cloneProps(new Container());
          if (recursive) { this._cloneChildren(o); }
          return o;
        },*/

        /*object_Stage.isVisible = function() {
          var hasContent = this.cacheCanvas || this.children.length;
          return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
        };
        object_Stage.draw = function(ctx, ignoreCache) {
          if (this.DisplayObject_draw(ctx, ignoreCache)) { 
            return true; 
          }
          
          // this ensures we don't have issues with display list changes that occur during a draw:
          var list = this.children.slice();
          for (var i=0,l=list.length; i<l; i++) {
            var child = list[i];
            if (!child.isVisible()) { 
              continue; 
            }
            
            // draw the child:
            ctx.save();
            //child.updateContext(ctx);
            child.draw(ctx);
            ctx.restore();
          }
          return true;
        };*/

        object_Stage.clear = function() {
          if (!this.canvas) { 
            return; 
          }
          var ctx = this.canvas.getContext("2d");
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1);
        };

        object_Stage.indexOf = function (array, searchElement){          
          for (var i = 0, l=array.length; i < l; i++) {
            if (searchElement === array[i]) {
              return i;
            }
          }
          return -1;
        };

        /*object_Stage.update = function(props) {
          if (!this.canvas) { 
            return; 
          }
          if (this.tickOnUpdate) { 
            this.tick(props); 
          }
          //if (this.dispatchEvent("drawstart", false, true) === false) { 
          //  console.log("Test 3");
          //  return; 
          //}
          //createjs.DisplayObject._snapToPixelEnabled = this.snapToPixelEnabled;
          var r = this.drawRect, ctx = this.canvas.getContext("2d");
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          if (this.autoClear) {
            if (r) { 
              ctx.clearRect(r.x, r.y, r.width, r.height); 
            }
            else { 
              ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1); 
            }
          }
          ctx.save();
          if (this.drawRect) {
            ctx.beginPath();
            ctx.rect(r.x, r.y, r.width, r.height);
            ctx.clip();
          }
          //this.updateContext(ctx);
          this.draw(ctx, false);
          ctx.restore();
          //this.dispatchEvent("drawend");
        };*/

        return object_Stage;
      }

      // fonction stage qui initialise l'objet joueur et elle est redefinie par celui-ci a chaque fois qu'on appelle la fonction remettreVariable()
      function object_Joueur() {
        // objet qui est retourne par la fonction
        var object_Joueur = {};

        object_Joueur.img = null;

        return object_Joueur;
      }

      /*function object_SpriteSheet() {
        var object_SpriteSheet = {};

        object_SpriteSheet.images = null;

        object_SpriteSheet.frames = null;

        object_SpriteSheet.animations = null;

        return object_SpriteSheet;
      }*/

      /*function background() {
        var background = object_Shape({

        });

        background.graphics.beginFill("#000000").drawRect(0, 0, canvas.width, canvas.height);
        objStage.addChild(background);
        document.body.style.background = "#250535";
      }

      function object_Shape() {
        var object_Shape = {};

        object_Shape.graphics = new graphics();

        object_Shape.isVisible = function() {
          var hasContent = this.cacheCanvas || (this.graphics && !this.graphics.isEmpty());
          return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
        };

        object_Shape.draw = function(ctx, ignoreCache) {
          if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
          this.graphics.draw(ctx, this);
          return true;
        };

        object_Shape.clone = function(recursive) {
          var g = (recursive && this.graphics) ? this.graphics.clone() : this.graphics;
          return  this._cloneProps(new Shape(g));
        };

        return object_Shape;
      }*/
    </script>
  </head>
  
  
  <body onload="initLodeRunner()"> 
    <canvas id="monCanvas" width="1440" height="1088" tabIndex="1" onkeydown="";>
      Votre navigateur ne supporte pas la balise canvas
    </canvas>
  </body>
</html>