<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
  <head>
  
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Lode Runner par Mohamed H. Guelleh & Andrew Chedid</title>
    <link rel="stylesheet" type="text/css" href="" />

    <script type="text/javascript" src="Graphics.js"></script>

    <script type="text/javascript">
      /*function strSprite (options) {
          
          var img = {};
          frameIndex = 0,
          tickCount = 0,
          ticksPerFrame = 0;
          numberOfFrames = options.numberOfFrames || 1;
                
          img.context = options.context;
          img.width = options.width;
          img.height = options.height;
          img.image = options.image;

          img.render = function () {
            // Draw the animation
            img.context.drawImage(img.image, frameIndex * img.width / numberOfFrames, 0, img.width / numberOfFrames, img.height, 0, 0, img.width / numberOfFrames, img.height);
          };

          img.loop = options.loop;

          img.update = function () {
            tickCount += 1;

            if (tickCount > ticksPerFrame) {
              tickCount = 0;

              // If the current frame index is in range
              if (frameIndex < numberOfFrames - 1) {	
                  // Go to the next frame
                  frameIndex += 1;
              }	else if (img.loop) {
                frameIndex = 0;
              }
            }
          };
      
          return img;
      }

      function initLoadRunner() {
        var objCanvas = document.getElementById('monCanvas'),
            objC2D = objCanvas.getContext('2d');

        objCanvas.focus();
        
        var width = objCanvas.width, 
            height = objCanvas.height;
        
        var imgTest = new Image();
        imgTest.src = "https://cdn.codeandweb.com/blog/2016/05/10/how-to-create-a-sprite-sheet/spritestrip.png";

        var test = strSprite({
          context: objC2D,
          width: 256,
          height: 256,
          image: imgTest
        });

        window.requestAnimationFrame(initLoadRunner);
        
        test.update();
        test.render();

        // Start the game loop as soon as the strSprite sheet is loaded
        test.addEventListener("load", initLoadRunner);
      }*/

      /*function gameLoop () {
        window.requestAnimationFrame(initLoadRunner);

        coin.update();
        coin.render();
      }*/

      
      

      // variables constantes
      const intNiveau_1 = 1, intNiveau_2 = 2, intNiveau_3 = 3;
      const intNum_Cell_X = 28, intNum_Cell_Y = 17;

      /* legende de la carte du niveau : 
          $ = or
          @ = Joueur
          ! = garde
          H = escalier
          | = escalier final
          - = corde
          # = passerelle de brique
          ~ = sol
            = vide
      */
     // array constante globale qui contient les cartes des differents niveau
      const arrNiveau_Map = [ 
        "                  |         " + // carte du niveau 1
        "    $             |         " +
        "#######H#######   |         " +
        "       H----------|    $    " +
        "       H    ##H   #######H##" +
        "       H    ##H          H  " +
        "     ! H    ##H       $! H  " +
        "##H#####    ########H#######" +
        "  H                 H       " +
        "  H           !     H       " +
        "#########H##########H       " +
        "         H          H       " +
        "       $ H----------H   $   " +
        "    H######         #######H" +
        "    H         @  $         H" +
        "############################" + 
        "~~~~~~~~~~~~~~~~~~~~~~~~~~~~" 
      ];
      // constantes globales qui contiennent les photos/sprites
      const srcSprites = "../assets/sprites/";
      const strSprite_Or = srcSprites + "gold.png", 
            strSprite_Joueur = srcSprites + "runner1.png", 
            strSprite_Garde = srcSprites + "guard1.png", 
            strSprite_Escalier = srcSprites + "ladder.png", 
            strSprite_Corde = srcSprites + "rope.png", 
            strSprite_Brique = srcSprites + "brick.png", 
            strSprite_Sol = srcSprites + "block.png",
            strSprite_Vide = srcSprites + "empty.png";

      // variables globales
      var objCanvas = null, 
          objC2D = null;

      var objStage = null; // stage qui contient tous les enfants a dessiner et a mettre dans le jeu

      var objJoueur = null, // lode runner que le Joueur controle
          //objMap = null, // representation des cellules dans un tableau array en 2d
          intNiveau_Courant = 0, // niveau courant du joueur
          intOr_Count = 0, // compte le nombre d'or qu'il y a dans le jeu
          intGarde_Count = 0; // compte le nombre de garde qu'il y a dans le jeu


      // remettre les variables globales aux valeurs par defaut
      function remettreVariables() {
        // redefini la fonction stage et le met dans la variable objStage
        objStage = object_Stage({ 
          name: "Main stage",
          toString: function() {
            return "[Stage  (name = "+  this.name +")]";
          }
        });

        // redefini la fonction joueur et le met dans la variable objJoueur
        objJoueur = object_Joueur({
        });

        /*objSprite_Sheet = object_SpriteSheet({
          images: [runnerImage],
		
          frames: {
            regX:0, 
            height: BASE_TILE_Y,  
            regY:0, 
            width: BASE_TILE_X
          },
          
          animations: { 
            runRight: [0,2, "runRight", RUNNER_SPEED], 
            runLeft : [3,5, "runLeft",  RUNNER_SPEED], 
            runUpDn : [6,7, "runUpDn",  RUNNER_SPEED],

            barRight: {
              frames: [ 18, 19, 19, 20, 20 ],
              next:  "barRight",
              speed: RUNNER_SPEED
            },

            barLeft: {
              frames: [ 21, 22, 22, 23, 23 ],
              next:  "barLeft",
              speed: RUNNER_SPEED
            },
                
            digRight: 24,
            digLeft : 25,

            fallRight : 8,
            fallLeft: 26
          }
        });*/

        //objMap = [[]];

        intNiveau_Courant = intNiveau_1; // niveau 1 par defaut

        intOr_Count = 0;
        intGarde_Count = 0;
      }

      // construire le niveau
      function construireNiveau(niveau) {
        // retourne le charactere aux positions (x,y) du niveau
        var intNiveau_Charactere_Count = 0; 

        // parcours les cellules horizontales
        for (var y = 0; y < intNum_Cell_Y; y++) { 
          // https://stackoverflow.com/questions/966225/how-can-i-create-a-two-dimensional-array-in-javascript
          // genere une erreure si on ne mets pas ca --> you have to set myArray[1]=[]; before assigning myArray[1][0]=5;
          //objMap[x] = []; 

          // parcours les cellues verticales
          for (var x = 0; x < intNum_Cell_X; x++) { 
          // cree un nouveau objet aux coordonnees (x,y)
            //objMap[x][y] = {}; 

            // retourne le charactere aux positions (x,y) du niveau
            var strNiveau_Charactere = niveau.charAt(intNiveau_Charactere_Count++);
            
            var objImage = object_Images({
            });
            objImage.strCharactere = strNiveau_Charactere,
            objImage.intX = x;
            objImage.intY = y;

            switch(strNiveau_Charactere) {
              /* legende de la carte du niveau : 
                  $ = or
                  @ = Joueur
                  ! = garde
                  H = escalier
                  | = escalier final
                  - = corde
                  # = passerelle de brique
                  ~ = sol
                    = vide
              */
              case "$": 
                intOr_Count++; 
                
                objImage.strSrc = strSprite_Or;
                //objImage.img = initImage(strSprite_Or, x, y);

                break;
              case "@": 
                objImage.strSrc = strSprite_Joueur;
                //objImage.img = objJoueur.img = initImage(strSprite_Joueur, x, y);

                break;
              case "!":
                intGarde_Count++; 

                objImage.strSrc = strSprite_Garde;
                //objImage.img = initImage(strSprite_Garde, x, y);

                break;
              case "H": 
                objImage.strSrc = strSprite_Escalier;
                //objImage.img = initImage(strSprite_Escalier, x, y);

                break;
              case "|": 
                objImage.strSrc = strSprite_Escalier;
                //objImage.img = initImage(strSprite_Escalier, x, y);

                break;
              case "-": 
                objImage.strSrc = strSprite_Corde;
                //objImage.img = initImage(strSprite_Corde, x, y);

                break;
              case "#":
                objImage.strSrc = strSprite_Brique;
                //objImage.img = initImage(strSprite_Brique, x, y);

                break;
              case "~": 
                objImage.strSrc = strSprite_Sol;
                //objImage.img = initImage(strSprite_Sol, x, y);

                break;
              case " ": 
                objImage.strSrc = strSprite_Vide;
                //objImage.img = initImage(strSprite_Vide, x, y);

                break;
            }

            objStage.addChild(objImage);
          }
        }     

        /*console.log(objStage.children);
        console.log(objStage.getNumChildren());
        console.log(objStage.getChildIndex("@"));
        console.log(objStage.getChildAt(406));

        objStage.removeChild("@");

        console.log(objStage.children);
        console.log(objStage.getNumChildren());
        console.log(objStage.getChildIndex("@"));
        console.log(objStage.getChildAt(406));*/

        //console.log(objJoueur.img);
      }

      /* legende de la carte du niveau : 
          $ = or
          @ = Joueur
          ! = garde
          H = escalier
          | = escalier final
          - = corde
          # = passerelle de brique
          ~ = sol
            = vide
      */
      function initLodeRunner() { // demarre le jeu
        // variables canvas 
        objCanvas = document.getElementById('monCanvas');
        objC2D = objCanvas.getContext('2d');

        objC2D.fillStyle = "black";
        objC2D.fillRect(0, 0, objCanvas.width, objCanvas.height);
        objCanvas.focus();
        
        remettreVariables();

        construireNiveau(arrNiveau_Map[intNiveau_Courant-1]);
        //animer();

        /*objStage.children.forEach(objImage => {
          if (objImage.getStrCharactere() === "|") {
            objStage.removeChild(objImage);
          }
        });*/

        /*objStage.getImageIndexAt("$");
        objStage.removeImageIndexAt("$", 17, 14);*/

        objStage.draw();

        objStage.removeAllImageIndex("!");

        objStage.clearDraw();

        //effacerDessin();

        //console.log(objStage.children);
      }

      // initialise les images
      // https://stackoverflow.com/questions/41463192/canvas-drawimage-loop-issue
      function initImage(imgSrc, x, y) {
        var image = new Image();
        
        image.src = imgSrc;

        image.onload = function(){
          objC2D.drawImage(image, x*(objCanvas.width/intNum_Cell_X), y*(objCanvas.height/intNum_Cell_Y), 52, 64);
        }

        return image;
      }

      var objCycleAnimation = null;
      function animer() {
        // RequÃªte pour le prochain cycle
        objCycleAnimation = requestAnimationFrame(animer);
	
        // Le cycle d'animation
        effacerDessin();
        mettreAJourAnimation();
        objStage.draw();
        //construireNiveau(arrNiveau_Map[intNiveau_Courant-1]);
        //setTimeout(animer, Math.floor(1000/60));
      }
      function effacerDessin() {
	      objC2D.clearRect(0,0, objCanvas.width, objCanvas.height); 
      }
      function mettreAJourAnimation() {
		    // A programmer
		    //fltAngleRotation += Math.PI/180;
      }
      function arreterAnimation() {
        if (objCycleAnimation != null)
            cancelAnimationFrame(objCycleAnimation);	
        objCycleAnimation = null;
      }

      // fonction stage qui initialise l'objet stage et 
      // elle est redefinie par celui-ci a chaque fois qu'on appelle la fonction remettreVariable()
      function object_Stage() {
        // objet qui est retourne par la fonction
        var object_Stage = {};

        object_Stage.name = null;
        object_Stage.toString = null;

        // ??????????????????????????????
        /*object_Stage.mouseChildren = true;
        object_Stage.tickChildren = true;*/

        object_Stage.canvas = objCanvas;

        //object_Stage.drawRect = null;

        object_Stage.children = [];
        
        object_Stage.getChildAt = function(index) {
          return this.children[index];
        };
        object_Stage.getChildByName = function(name) {
          var kids = this.children;
          for (var i=0,l=kids.length;i<l;i++) {
            if(kids[i].name == name) { return kids[i]; }
          }
          return null;
        };
        object_Stage.getChildIndex = function(child) {
          return this.indexOf(this.children, child);
        };
        object_Stage.getNumChildren = function () {
          return this.children.length;
        };

        object_Stage.addChild = function(child) {
          if (child == null) { return child; }
          var l = arguments.length;
          if (l > 1) {
            for (var i=0; i<l; i++) { this.addChild(arguments[i]); }
            return arguments[l-1];
          }
          // Note: a lot of duplication with addChildAt, but push is WAY faster than splice.
          var par=child.parent, silent = par === this;
          par&&par._removeChildAt(this.indexOf(par.children, child), silent);
          child.parent = this;
          this.children.push(child);
          //if (!silent) { child.dispatchEvent("added"); }
          return child;
        };
        object_Stage.addChildAt = function(child, index) {
          var l = arguments.length;
          var indx = arguments[l-1]; // can't use the same name as the index param or it replaces arguments[1]
          if (indx < 0 || indx > this.children.length) { return arguments[l-2]; }
          if (l > 2) {
            for (var i=0; i<l-1; i++) { this.addChildAt(arguments[i], indx+i); }
            return arguments[l-2];
          }
          var par=child.parent, silent = par === this;
          par&&par._removeChildAt(this.indexOf(par.children, child), silent);
          child.parent = this;
          this.children.splice(index, 0, child);
          //if (!silent) { child.dispatchEvent("added"); }
          return child;
        };

        object_Stage._removeChildAt = function(index, silent) {
          if (index < 0 || index > this.children.length-1) { return false; }
          var child = this.children[index];
          if (child) { child.parent = null; }
          this.children.splice(index, 1);
          //if (!silent) { child.dispatchEvent("removed"); }
          return true;
        };
        object_Stage.removeChild = function(child) {
          var l = arguments.length;
          if (l > 1) {
            var good = true;
            for (var i=0; i<l; i++) { good = good && this.removeChild(arguments[i]); }
            return good;
          }
          return this._removeChildAt(this.indexOf(this.children, child));
        };
        object_Stage.removeChildAt = function(index) {
          var l = arguments.length;
          if (l > 1) {
            var a = [];
            for (var i=0; i<l; i++) { a[i] = arguments[i]; }
            a.sort(function(a, b) { return b-a; });
            var good = true;
            for (var i=0; i<l; i++) { good = good && this._removeChildAt(a[i]); }
            return good;
          }
          return this._removeChildAt(index);
        };
        object_Stage.removeAllChildren = function() {
          var kids = this.children;
          while (kids.length) { this._removeChildAt(0); }
        };

        object_Stage.getImageIndexAt = function(strCharactere) {
          this.children.forEach(objImage => {
            if (objImage.getStrCharactere() === strCharactere) {
              console.log(objImage.toString());
            }
          });
        };
        
        object_Stage.removeImageIndexAt = function(strCharactere, x, y) {
          var blnTrouve = false,
              intCount = 0,
              intX = x,
              intY = y;

          this.children.forEach(objImage => {
            if (objImage.getStrCharactere() === strCharactere && objImage.getX() == intX && objImage.getY() == intY) {
              blnTrouve = true;
              intCount++;

              this.removeChild(objImage);
            }
          });

          if (blnTrouve) {
            console.log("L'image \"" + strCharactere + "\" a ete enlevee " + intCount + "nb de fois aux coordonnees (" + intX + "x, " + intY + "y)");
          }
          else {
            console.log("L'image \"" + strCharactere + "\" n'a pas ete trouvee aux coordonnees (" + intX + "x, " + intY + "y)");
          }
        };
        object_Stage.removeAllImageIndex = function(strCharactere) {
          var blnTrouve = false,
              intCount = 0;

          this.children.forEach(objImage => {
            if (objImage.getStrCharactere() === strCharactere) {
              blnTrouve = true;
              intCount++;

              this.removeChild(objImage);
            }
          });

          if (blnTrouve) {
            console.log("L'image \"" + strCharactere + "\" a ete enlevee " + intCount + "nb de fois");
          }
          else {
            console.log("L'image \"" + strCharactere + "\" n'a pas ete trouvee");
          }
        };

        object_Stage.sortChildren = function(sortFunction) {
          this.children.sort(sortFunction);
        };

        /*clone: function(recursive) {
          var o = this._cloneProps(new Container());
          if (recursive) { this._cloneChildren(o); }
          return o;
        },*/

        /*object_Stage.isVisible = function() {
          var hasContent = this.cacheCanvas || this.children.length;
          return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
        };
        object_Stage.draw = function(ctx, ignoreCache) {
          if (this.DisplayObject_draw(ctx, ignoreCache)) { 
            return true; 
          }
          
          // this ensures we don't have issues with display list changes that occur during a draw:
          var list = this.children.slice();
          for (var i=0,l=list.length; i<l; i++) {
            var child = list[i];
            if (!child.isVisible()) { 
              continue; 
            }
            
            // draw the child:
            ctx.save();
            //child.updateContext(ctx);
            child.draw(ctx);
            ctx.restore();
          }
          return true;
        };*/

        // !!! marche pas !!!
        object_Stage.clear = function() {
          if (!this.canvas) { 
            return; 
          }
          var ctx = this.canvas.getContext("2d");
          //ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.fillStyle = "white";
          ctx.fillRect(0, 0, this.canvas.width+1, this.canvas.height+1);
        };

        object_Stage.indexOf = function (array, searchElement){          
          for (var i = 0, l=array.length; i < l; i++) {
            if (searchElement === array[i]) {
              return i;
            }
          }
          return -1;
        };

        object_Stage.draw = function() {
          this.children.forEach(objImage => {
            var image = new Image();
        
            image.src = objImage.getStrSrc();

            image.onload = function(){
              objC2D.drawImage(image, objImage.getX()*(objCanvas.width/intNum_Cell_X), objImage.getY()*(objCanvas.height/intNum_Cell_Y), 52, 64);
            }

            objImage.img = image;
          });
        };
        object_Stage.clearDraw = function() {
          this.children.forEach(objImage => {
            var image = new Image();
        
            image.src = strSprite_Vide;

            image.onload = function(){
              objC2D.globalCompositeOperation ="xor"
              objC2D.drawImage(image, objImage.getX()*(objCanvas.width/intNum_Cell_X), objImage.getY()*(objCanvas.height/intNum_Cell_Y), 52, 64);
            }

            objImage.img = image;
          });
        };

        /*object_Stage.update = function(props) {
          if (!this.canvas) { 
            return; 
          }
          if (this.tickOnUpdate) { 
            this.tick(props); 
          }
          //if (this.dispatchEvent("drawstart", false, true) === false) { 
          //  console.log("Test 3");
          //  return; 
          //}
          //createjs.DisplayObject._snapToPixelEnabled = this.snapToPixelEnabled;
          var r = this.drawRect, ctx = this.canvas.getContext("2d");
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          if (this.autoClear) {
            if (r) { 
              ctx.clearRect(r.x, r.y, r.width, r.height); 
            }
            else { 
              ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1); 
            }
          }
          ctx.save();
          if (this.drawRect) {
            ctx.beginPath();
            ctx.rect(r.x, r.y, r.width, r.height);
            ctx.clip();
          }
          //this.updateContext(ctx);
          this.draw(ctx, false);
          ctx.restore();
          //this.dispatchEvent("drawend");
        };*/

        return object_Stage;
      }

      // fonction stage qui initialise l'objet joueur et 
      // elle est redefinie par celui-ci a chaque fois qu'on appelle la fonction remettreVariable()
      function object_Joueur() {
        // objet qui est retourne par la fonction
        var object_Joueur = {};

        object_Joueur.img = null;

        return object_Joueur;
      }

      function object_Images() {
        var object_Images = {};

        object_Images.strCharactere = null;
        object_Images.intX = null;
        object_Images.intY = null;
        object_Images.strSrc = null;
        object_Images.img = null;

        object_Images.toString = function() {
          return "[\n" + 
                  "\t" + "Image \n" + 
                  "\t" + "charactere:\t" + this.strCharactere + ",\n" + 
                  "\t" + "x:\t" + this.intX + ",\n" + 
                  "\t" + "y:\t" + this.intY + ",\n" + 
                  "\t" + "src:\t" + this.strSrc + 
                  "\n]\n\n";
        };

        object_Images.getStrCharactere = function() {
          return this.strCharactere;
        };
        object_Images.getX = function() {
          return this.intX;
        };
        object_Images.getY = function() {
          return this.intY;
        };
        object_Images.getStrSrc = function() {
          return this.strSrc;
        };
        object_Images.getImg = function() {
          return this.img;
        };

        return object_Images;
      }

      /*function object_SpriteSheet() {
        var object_SpriteSheet = {};

        object_SpriteSheet.images = null;

        object_SpriteSheet.frames = null;

        object_SpriteSheet.animations = null;

        return object_SpriteSheet;
      }*/

      /*function background() {
        var background = object_Shape({

        });

        background.graphics.beginFill("#000000").drawRect(0, 0, canvas.width, canvas.height);
        objStage.addChild(background);
        document.body.style.background = "#250535";
      }

      function object_Shape() {
        var object_Shape = {};

        object_Shape.graphics = new graphics();

        object_Shape.isVisible = function() {
          var hasContent = this.cacheCanvas || (this.graphics && !this.graphics.isEmpty());
          return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
        };

        object_Shape.draw = function(ctx, ignoreCache) {
          if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
          this.graphics.draw(ctx, this);
          return true;
        };

        object_Shape.clone = function(recursive) {
          var g = (recursive && this.graphics) ? this.graphics.clone() : this.graphics;
          return  this._cloneProps(new Shape(g));
        };

        return object_Shape; 
      }*/
    </script>
  </head>
  
  
  <body onload="initLodeRunner()"> 
    <canvas id="monCanvas" width="1440" height="1088" tabIndex="1" onkeydown="";>
      Votre navigateur ne supporte pas la balise canvas
    </canvas>
  </body>
</html>